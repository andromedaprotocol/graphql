# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Account {
  account_number: Int!
  address: String!
  public_key: PublicKeyUnion
  sequence: Int!
}

type AddressListAdo implements BaseAdo {
  adoId: String!
  adoType: String!
  contractQuery: Anything!
  isInclusive: Boolean!
  modules: [AndrModule!]
  operators: [String!]!
  primitiveContract: String
}

enum AdoType {
  AddressList
  AdoOffers
  Auction
  Crowdfund
  Mission
  Primitive
  Rates
  Receipt
  Splitter
  Timelock
  Token
}

type AllNftInfo {
  access: NftOwnerInfo!
  info: NftInfo!
}

type AnchorAdo implements BaseAdo {
  adoId: String!
  adoType: String!
  contractQuery: Anything!
  modules: [AndrModule!]
  operators: [String!]
  primitiveContract: String!
}

type AndrAddress {
  identifier: String!
}

type AndrAddressPercent {
  percent: Float!
  recipient: AndrRecipient!
}

type AndrCW20Coin {
  address: String!
  amount: Int!
}

type AndrExpiration {
  expirationType: AndrExpirationType!
  expirationValue: String!
}

enum AndrExpirationType {
  AtHeight
  AtTime
  Never
}

type AndrLogo {
  data: String!
  link: String!
  mimeType: String!
}

type AndrMarketingInfo {
  description: String
  logo: AndrLogo
  marketing: String
  project: String
}

type AndrMinterResponse {
  cap: Int
  minter: String!
}

type AndrMissionComponent {
  adoType: AdoType!
  instantiateMsg: String!
  name: String!
}

type AndrModule {
  address: AndrAddress!
  isMutable: Boolean!
  moduleType: AndrModuleType!
}

enum AndrModuleType {
  AddressList
  Offers
  Rates
  Receipt
}

enum AndrOrderBy {
  Asc
  Desc
}

type AndrRateInfo {
  description: String!
  isAdditive: Boolean!
  rate: AndrRateType!
  receivers: [AndrRecipient!]!
}

enum AndrRateType {
  External
  Flat
  Percent
}

type AndrRecipient {
  address: AndrAddress!
  msg: String
}

input AndrSearchOptions {
  limit: Int = 10
  orderBy: AndrOrderBy = Asc
  startAfter: Int = 0
}

enum AndrStrategyType {
  Anchor
}

type AndrYieldStrategy {
  address: String!
  strategyType: AndrStrategyType!
}

scalar Anything

type Auction {
  auctionIds(tokenAddress: String!, tokenId: String!): [Int!]!
  auctionInfo(options: AndrSearchOptions, tokenAddress: String!): AuctionInfo!
  auctionState(auctionId: Float!): AuctionAdo!
  bids(auctionId: Float!, options: AndrSearchOptions): [Bid!]!
  isOperator: Boolean!
  latestAuctionState(tokenAddress: String!, tokenId: String!): AuctionAdo!
  operators: [String!]!
  owner: String!
}

type AuctionAdo implements BaseAdo {
  adoId: String!
  adoType: String!
  auctionId: Int!
  coinDenom: String!
  contractQuery: Anything!
  endTime: AndrExpiration!
  highBidderAddr: AndrAddress!
  highBidderAmount: Int!
  isCancelled: Boolean!
  modules: [AndrModule!]
  operators: [String!]
  owner: String!
  primitiveContract: String
  startTime: AndrExpiration!
  tokenAddress: String!
  tokenId: String!
  whitelist: [AndrAddress!]
}

type AuctionInfo {
  auctionIds: [Int!]!
  tokenAddress: String!
  tokenId: String!
}

type Auth {
  accountInfo(address: String!, height: Float): Account!
}

interface BaseAdo {
  adoId: String!
  adoType: String!
  contractQuery: Anything!
  modules: [AndrModule!]
  operators: [String!]
  primitiveContract: String
}

type Bid {
  amount: Int!
  bidder: String!
  timestamp: String!
}

type CW20TokenAdo implements BaseAdo {
  adoId: String!
  adoType: String!
  contractQuery: Anything!
  decimals: Int!
  initial_balances: [AndrCW20Coin!]!
  marketing: AndrMarketingInfo
  mint: AndrMinterResponse
  modules: [AndrModule!]
  name: String!
  operators: [String!]
  primitiveContract: String
  symbol: String!
}

type CodeInfo {
  code_creator: String!
  code_hash: String!
}

type Coin {
  amount: String!
  denom: String!
}

input CoinInput {
  amount: String!
  denom: String!
}

type CommissionRates {
  max_change_rate: String!
  max_rate: String!
  rate: String!
}

type ContractInfo {
  address: String!
  admin: String
  code_id: Int!
  init_msg: JSON!
  owner: String!
}

type CrowdfundAdo implements BaseAdo {
  adoId: String!
  adoType: String!
  canMintAfterSale: Boolean!
  contractQuery: Anything!
  modules: [AndrModule!]
  operators: [String!]
  primitiveContract: String!
  tokenAddress: AndrAddress!
}

type DepositParams {
  max_deposit_period: Int!
  min_deposit: [Coin!]!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type LegacyAminoMultisigPublicKey {
  public_keys: [SimplePublicKey!]!
  threshold: Float!
}

type MissionAdo implements BaseAdo {
  adoId: String!
  adoType: String!
  contractQuery: Anything!
  mission: [AndrMissionComponent!]!
  modules: [AndrModule!]
  name: String!
  operators: [String!]!
  primitiveContract: String!
}

type NFT {
  allNftInfo(includeExpired: Boolean!, tokenId: String!): AllNftInfo!
  allTokens(options: AndrSearchOptions): [String!]!
  approvals(includeExpired: Boolean!, options: AndrSearchOptions, owner: String!): [NftApproval!]!
  contractInfo: NftContractInfo!
  isOperator: Boolean!
  minter: String!
  nftInfo(tokenId: String!): NftInfo!
  numTokens: Int!
  operators: [String!]!
  owner: String!
  ownerOf(includeExpired: Boolean!, tokenId: String!): NftOwnerInfo!
  tokens(options: AndrSearchOptions, owner: String!): [String!]!
}

type NftApproval {
  expires: AndrExpiration!
  spender: String!
}

type NftContractInfo {
  name: String!
  symbol: String!
}

type NftInfo {
  extension: Anything!
  tokenUri: String!
}

type NftOwnerInfo {
  approvals: [NftApproval!]!
  owner: String!
}

type OfferInfo {
  denom: String!
  expiration: AndrExpiration!
  offerAmount: Int!
  purchaser: String!
  remainingAmount: Int!
  taxAmount: Int!
}

type Offers {
  allOffers(options: AndrSearchOptions!, purchaser: String!): [OfferInfo!]!
  offer(tokenId: String!): OfferInfo!
}

type OracleWhitelist {
  name: String!
  tobin_tax: String!
}

type ParameterChanges {
  key: String!
  subspace: String!
  value: String!
}

type PolicyConstraints {
  cap: Coin!
  change_max: String!
  rate_max: String!
  rate_min: String!
}

type PrimitiveAdo implements BaseAdo {
  adoId: String!
  adoType: String!
  contractQuery: Anything!
  modules: [AndrModule!]
  operators: [String!]!
  primitiveContract: String
}

union PublicKeyUnion = LegacyAminoMultisigPublicKey | SimplePublicKey | ValConsPublicKey

type Query {
  addresslist: AddressListAdo!
  anchor: AnchorAdo!
  auction: Auction!
  auth: Auth!
  crowdfund: CrowdfundAdo!
  cw20token: CW20TokenAdo!
  mission: MissionAdo!
  nft: NFT!
  offers: Offers!
  ping: String!
  primitive: PrimitiveAdo!
  rates: RatesAdo!
  receipt: ReceiptAdo!
  splitter: SplitterAdo!
  timelock: TimelockAdo!
  vault: VaultAdo!
  wasm: Wasm!
}

type RatesAdo implements BaseAdo {
  adoId: String!
  adoType: String!
  contractQuery: Anything!
  modules: [AndrModule!]
  operators: [String!]
  primitiveContract: String
  rates: [AndrRateInfo!]!
}

type ReceiptAdo implements BaseAdo {
  adoId: String!
  adoType: String!
  contractQuery: Anything!
  minter: String!
  modules: [AndrModule!]
  operators: [String!]
  primitiveContract: String
}

type ScheduleEntry {
  end_time: String!
  ratio: String!
  start_time: String!
}

type SimplePublicKey {
  key: String!
}

type SplitterAdo implements BaseAdo {
  adoId: String!
  adoType: String!
  contractQuery: Anything!
  modules: [AndrModule!]
  operators: [String!]
  primitiveContract: String
  recipients: [AndrAddressPercent!]
}

type StakeAuthorizationValidators {
  addresses: [String!]!
}

type TallyParams {
  quorum: String!
  threshold: String!
  veto_threshold: String!
}

type TimelockAdo implements BaseAdo {
  adoId: String!
  adoType: String!
  contractQuery: Anything!
  modules: [AndrModule!]
  operators: [String!]
  primitiveContract: String
}

type ValConsPublicKey {
  key: String!
}

type ValidatorCommission {
  commission_rates: CommissionRates!
  update_time: String!
}

type ValidatorDescription {
  details: String!
  identity: String!
  moniker: String!
  security_contact: String!
  website: String!
}

type VaultAdo implements BaseAdo {
  adoId: String!
  adoType: String!
  contractQuery: Anything!
  modules: [AndrModule!]
  operators: [String!]
  primitiveContract: String
  strategies: [AndrYieldStrategy!]!
}

type VestingSchedule {
  denom: String!
  schedules: [ScheduleEntry!]!
}

enum VoteOption {
  Abstain
  Empty
  No
  NoWithVeto
  Yes
}

type VotingParams {
  voting_period: Int!
}

type Wasm {
  codeInfo(codeID: Int!, height: Float): CodeInfo!
  contractInfo(contractAddress: String!, height: Float!): ContractInfo!
  contractQuery(contractAddress: String!, height: Float, query: JSON!): Anything!
  parameters(height: Float): WasmParams!
}

type WasmParams {
  max_contract_gas: Int
  max_contract_msg_size: Int
  max_contract_size: Int
}

type WeightedVoteOption {
  option: VoteOption!
  weight: String!
}
