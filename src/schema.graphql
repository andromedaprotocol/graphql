# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type ADORate {
  address: String!
  key: String!
}

type AddressListQuery {
  contractAddress: String!
  includesAddress(address: String!): AddressListResponse!
  isOperator(operatorAddress: String!): Boolean!
  operators: [String!]!
  owner: String!
}

type AddressListResponse {
  included: Boolean!
}

type AddressPercent {
  percent: String!
  recipient: AndrRecipient!
}

type AdoContract implements BaseAdoContract {
  address: String!
  admin: String
  adoType: AdoType!
  codeId: Int!
  creator: String!
  ibcPortId: String
  isOperator(operator: String!): Boolean!
  label: String!
  operators: [String!]!
  owner: String!
  queries_expected: [String!]
}

type AdoContractError {
  code: Int
  error: String!
}

union AdoContractResult = AdoContract | AdoContractError

enum AdoType {
  AddressList
  Ado
  AdoOffers
  App
  Auction
  CW20Token
  Crowdfund
  NFTCollectible
  Primitive
  Rates
  Receipt
  Splitter
  Timelock
  Vault
}

type Agreement {
  amount: AgreementAmount
  purchaser: String
}

type AgreementAmount {
  raw: AndrCoin
}

type AllNftInfo {
  access: NftOwnerInfo
  info: NftInfo
}

type AnchorQuery {
  contractAddress: String!
  isOperator(operatorAddress: String!): Boolean!
  operators: [String!]!
  owner: String!
}

type AndrADORecipient {
  address: AndrAddress!
  msg: String
}

type AndrAddress {
  identifier: String!
}

type AndrCoin {
  amount: String!
  denom: String!
}

input AndrCoinInput {
  amount: String!
  denom: String!
}

type AndrExpiration {
  at_height: Int
  at_time: String
}

type AndrModule {
  address: AndrAddress!
  isMutable: Boolean!
  moduleType: AndrModuleType!
}

enum AndrModuleType {
  AddressList
  Offers
  Rates
  Receipt
}

enum AndrOrderBy {
  Asc
  Desc
}

type AndrRecipient {
  a_d_o: AndrADORecipient
  addr: String
}

input AndrSearchOptions {
  limit: Int = 10
  orderBy: AndrOrderBy = Asc
  startAfter: Int = 0
}

type AndrStrategy {
  address: String
  strategyType: AndrStrategyType
}

enum AndrStrategyType {
  Anchor
}

scalar Anything

type AppComponent {
  ado_type: String!
  instantiate_msg: String!
  name: String!
}

type AppComponentAddress {
  address: String!
  name: String!
}

type AppConfig {
  name: String!
  owner: String!
}

type AppContract implements BaseAdoContract {
  address: String!
  addresses: [AppComponentAddress!]!
  admin: String
  adoType: AdoType!
  codeId: Int!
  componentExists(name: String!): Boolean!
  components: [AppComponent!]!
  config: AppConfig!
  creator: String!
  getAddress(name: String!): String!
  ibcPortId: String
  isOperator(operator: String!): Boolean!
  label: String!
  operators: [String!]!
  owner: String!
  queries_expected: [String!]
}

union AppContractResult = AdoContractError | AppContract

type Auction {
  auctionIds(tokenAddress: String!, tokenId: String!): [Int!]!
  auctionInfo(options: AndrSearchOptions, tokenAddress: String!): AuctionInfo!
  auctionState(auctionId: Float!): AuctionAdo!
  bids(auctionId: Float!, options: AndrSearchOptions): [Bid!]!
  isOperator: Boolean!
  latestAuctionState(tokenAddress: String!, tokenId: String!): AuctionAdo!
  operators: [String!]!
  owner: String!
}

type AuctionAdo implements BaseAdo {
  adoId: String!
  adoType: String!
  auctionId: Int!
  coinDenom: String!
  contractQuery: Anything!
  endTime: AndrExpiration!
  highBidderAddr: AndrAddress!
  highBidderAmount: Int!
  isCancelled: Boolean!
  modules: [AndrModule!]
  operators: [String!]
  owner: String!
  primitiveContract: String
  startTime: AndrExpiration!
  tokenAddress: String!
  tokenId: String!
  whitelist: [AndrAddress!]
}

type AuctionInfo {
  auctionIds: [Int!]!
  tokenAddress: String!
  tokenId: String!
}

interface BaseAdo {
  adoId: String!
  adoType: String!
  contractQuery: Anything!
  modules: [AndrModule!]
  operators: [String!]
  primitiveContract: String
}

interface BaseAdoContract {
  address: String!
  admin: String
  codeId: Int!
  creator: String!
  ibcPortId: String
  label: String!
  operators: [String!]!
  owner: String!
  queries_expected: [String!]
}

interface BaseContract {
  address: String!
  admin: String
  codeId: Int!
  creator: String!
  ibcPortId: String
  label: String!
  queries_expected: [String!]
}

type Bid {
  amount: Int!
  bidder: String!
  timestamp: String!
}

type CW20TokenContract implements BaseAdoContract {
  address: String!
  admin: String
  adoType: AdoType!
  codeId: Int!
  creator: String!
  ibcPortId: String
  isOperator(operator: String!): Boolean!
  label: String!
  operators: [String!]!
  owner: String!
  queries_expected: [String!]
  tokenInfo: TokenInfo!
  tx: [TxInfo!]!
}

type CrowdfundConfig {
  can_mint_after_sale: Boolean!
  token_address: AndrAddress!
}

type CrowdfundContract implements BaseAdoContract {
  address: String!
  admin: String
  adoType: AdoType!
  availableTokens: [String!]!
  codeId: Int!
  config: CrowdfundConfig!
  creator: String!
  ibcPortId: String
  isOperator(operator: String!): Boolean!
  isTokenAvailable(tokenId: String!): Boolean!
  label: String!
  operators: [String!]!
  owner: String!
  queries_expected: [String!]
  state: CrowdfundState!
}

union CrowdfundContractResult = AdoContractError | CrowdfundContract

type CrowdfundState {
  amount_sold: Int
  amount_to_send: Int
  amount_transferred: Int
  expiration: AndrExpiration
  max_amount_per_wallet: Int
  min_tokens_sold: Int
  price: AndrCoin
  recipient: AndrRecipient
}

union Cw20TokenContractResult = AdoContractError | CW20TokenContract

type Escrow {
  coins: [AndrCoin!]!
  condition: EscrowCondition
  recipient: AndrRecipient!
}

type EscrowCondition {
  expiration: AndrExpiration
  miniumFunds: [AndrCoin!]
}

type NftApproval {
  expires: AndrExpiration
  spender: String
}

type NftContract implements BaseAdoContract {
  address: String!
  admin: String
  adoType: AdoType!
  allNftInfo(includeExpired: Boolean!, tokenId: String!): AllNftInfo!
  allOperators(includeExpired: Boolean!, options: AndrSearchOptions, owner: String!): [NftApproval!]!
  allTokens(options: AndrSearchOptions): [String!]!
  approval(includeExpired: Boolean!, spender: String!, tokenId: String!): NftApproval!
  approvals(includeExpired: Boolean!, tokenId: String!): [NftApproval!]!
  codeId: Int!
  contractInfo: NftContractInfo!
  creator: String!
  ibcPortId: String
  isArchived(tokenId: String!): Boolean!
  isOperator(operator: String!): Boolean!
  label: String!
  minter: String!
  nftInfo(tokenId: String!): NftInfo!
  numTokens: Int!
  operators: [String!]!
  owner: String!
  ownerOf(includeExpired: Boolean!, tokenId: String!): NftOwnerInfo!
  queries_expected: [String!]
  tokens(options: AndrSearchOptions, owner: String!): [String!]!
  transferAgreement(tokenId: String!): TransferAgreement!
}

type NftContractInfo {
  name: String
  symbol: String
}

union NftContractResult = AdoContractError | NftContract

type NftInfo {
  extension: Anything
  tokenUri: String
}

type NftOwnerInfo {
  approvals: [NftApproval!]
  owner: String
}

type OfferResponse {
  denom: String!
  expiration: AndrExpiration!
  offerAmount: Int!
  purchaser: String!
  remainingAmount: Int!
  taxAmount: Int!
}

type OffersQuery {
  allOffers(options: AndrSearchOptions!, purchaser: String!): [OfferResponse!]!
  contractAddress: String!
  offer(tokenId: String!): OfferResponse!
}

type PercentRate {
  decimal: Float!
}

type Primitive {
  bool: Boolean
  coin: AndrCoin
  decimal: Float
  string: String
  uint128: Int
  vec: [Primitive!]
}

type PrimitiveContract implements BaseAdoContract {
  address: String!
  admin: String
  adoType: AdoType!
  codeId: Int!
  creator: String!
  getValue(key: String!): PrimitiveResponse!
  ibcPortId: String
  isOperator(operator: String!): Boolean!
  label: String!
  operators: [String!]!
  owner: String!
  queries_expected: [String!]
}

union PrimitiveContractResult = AdoContractError | PrimitiveContract

type PrimitiveResponse {
  key: String!
  value: Primitive!
}

type Query {
  addresslist(contractAddress: String!): AddressListQuery!
  ado(address: String!): AdoContractResult!
  anchor(contractAddress: String!): AnchorQuery!
  app(address: String!): AppContractResult!
  auction: Auction!
  crowdfund(address: String!): CrowdfundContractResult!
  cw20token(address: String!): Cw20TokenContractResult!
  nft(address: String!): NftContractResult!
  offers(contractAddress: String!): OffersQuery!
  ping: String!
  primitive(address: String!): PrimitiveContractResult!
  rates(contractAddress: String!): RatesQuery!
  splitter(address: String!): SplitterContractResult!
  timelock(contractAddress: String!): TimelockQuery!
  vault(address: String!): VaultContractResult!
  wasm(address: String!): WasmContractResult!
}

type Rate {
  external: ADORate!
  flat: AndrCoin!
  percent: PercentRate!
}

type RateInfo {
  description: String!
  is_additive: Boolean!
  rate: Rate!
  receivers: [AndrRecipient!]!
}

type RatesQuery {
  contractAddress: String!
  isOperator(operatorAddress: String!): Boolean!
  operators: [String!]!
  owner: String!
  payments: [RateInfo!]!
}

type Splitter {
  locked: Boolean!
  recipients: [AddressPercent!]!
}

type SplitterContract implements BaseAdoContract {
  address: String!
  admin: String
  adoType: AdoType!
  codeId: Int!
  config: Splitter!
  creator: String!
  ibcPortId: String
  isOperator(operator: String!): Boolean!
  label: String!
  operators: [String!]!
  owner: String!
  queries_expected: [String!]
}

union SplitterContractResult = AdoContractError | SplitterContract

type TimelockQuery {
  contractAddress: String!
  getLockedFunds(owner: String!, recipient: String!): Escrow!
  getLockedFundsForRecipient(options: AndrSearchOptions!, recipient: String!): [Escrow!]!
  isOperator(operatorAddress: String!): Boolean!
  operators: [String!]!
  owner: String!
}

type TokenInfo {
  decimals: Int!
  name: String!
  symbol: String!
  total_supply: Float!
}

type TransferAgreement {
  agreement: Agreement
  tokenId: String
}

type TxInfo {
  code: Int!
  gasUsed: Int!
  gasWanted: Int!
  hash: String!
  height: Int!
  rawLog: String!
  tx: [Int!]!
}

type VaultContract implements BaseAdoContract {
  address: String!
  admin: String
  adoType: AdoType!
  balance(address: String!): [AndrCoin!]!
  codeId: Int!
  creator: String!
  ibcPortId: String
  isOperator(operator: String!): Boolean!
  label: String!
  operators: [String!]!
  owner: String!
  queries_expected: [String!]
  strategyAddress(strategy: String!): AndrStrategy!
}

union VaultContractResult = AdoContractError | VaultContract

type WasmContract implements BaseContract {
  address: String!
  admin: String
  codeId: Int!
  creator: String!
  ibcPortId: String
  label: String!
  queries_expected: [String!]
}

type WasmContractError {
  code: Int
  error: String!
}

union WasmContractResult = WasmContract | WasmContractError
